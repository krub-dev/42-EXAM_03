# 42 Exam Rank 03 - Ejercicios Level 1 y Level 2

Este repo contiene la recopilación estructurada de los ejercicios típicos de los niveles 1 y 2 del examen Rank 03 de 42, incluyendo los enunciados en principio originales (`subject.txt`) y el esqueleto base de cada ejercicio.

---

## Nivel 1

### 1. filter
- **Objetivo:** Recibe una cadena `s` como argumento. Lee de stdin y escribe en stdout, pero cada ocurrencia de `s` la reemplaza por asteriscos (`*`).
- **Salida:** El texto leído, con las ocurrencias de `s` sustituidas por `*`.
- **Técnica:** Manipulación de strings, búsqueda y reemplazo, lectura bufferizada.
- **Temas:** Strings, stdin/stdout, manejo de memoria, errores de sistema.
- **Funciones permitidas:** `read`, `strlen`, `malloc`, `calloc`, `realloc`, `free`, `printf`, `perror`
- **Tipo:** Programa completo (con `main` propio, ejecutable).

### 2. ft_scanf
- **Objetivo:** Implementar una función `ft_scanf(const char *, ...)` que simula scanf, soportando solo `%s`, `%d` y `%c`.
- **Salida:** Número de conversiones exitosas.
- **Técnica:** Parseo manual de input con `fgetc`, `ungetc`, y manejo de argumentos variables (`va_list`).
- **Temas:** Entrada estándar, parsing, argumentos variables, tipos básicos.
- **Funciones permitidas:** `fgetc`, `ungetc`, `ferror`, `feof`, `isspace`, `isdigit`, `stdin`, `va_start`, `va_arg`, `va_copy`, `va_end`
- **Tipo:** Solo la función/código, ellos prueban con su propio main.

### 3. broken_gnl
- **Objetivo:** Reparar la función `get_next_line(int fd)` en el archivo proporcionado, para que devuelva la siguiente línea (incluyendo `\n` si existe) de un descriptor de archivo en cada llamada.
- **Salida:** String con la línea leída, o `NULL` si no hay más.
- **Técnica:** Lectura bufferizada, gestión de memoria y buffers estáticos/dinámicos, usando solo las funciones permitidas.
- **Temas:** Archivos, lectura por bloques, manejo de memoria.
- **Funciones permitidas:**  
  `read`, `malloc`, `free`
- **Tipo:** Solo debes reparar la función/código en los archivos indicados. El equipo evaluador probará con su propio main.

### ¿Qué tienen en común los ejercicios de Nivel 1?
- El foco está en **entrada/salida** (stdin/stdout, fds), manipulación de buffers y strings, y manejo manual de memoria.

---

### ¿Qué significa entrada/salida (I/O) en estos ejercicios?

**Entrada**
- Los programas reciben datos de:
  - `stdin` (entrada estándar), lo que el usuario teclea o redirecciona al ejecutar el programa.
  - `fd` (file descriptor), que puede ser un archivo o incluso stdin, según el ejercicio.
- Se lee usando funciones como `read` (bajo nivel) o `fgetc` (más alto nivel), permitiendo leer datos byte a byte o por bloques.
- Los datos pueden ser cadenas de texto, números, o líneas completas, que normalmente se procesan usando buffers (arrays de caracteres).

**Salida**
- Los resultados se envían a:
  - `stdout` (salida estándar), lo que el usuario ve o lo que puede redirigirse a un archivo.
- Se escribe usando funciones como `write` o `printf`, para mostrar texto, resultados, o datos procesados.
- El formato de la salida importa: puede requerir texto modificado, números, líneas, etc., según el enunciado.

**¿Por qué es importante?**
- **Control total:** No puedes usar funciones avanzadas que hagan todo por ti. Debes controlar cómo se lee y se escribe, y cómo se almacenan temporalmente los datos (buffers).
- **Eficiencia y seguridad:** Leer y escribir correctamente evita errores de corrupción de datos, fugas de memoria y resultados inesperados.
- **Ejemplo concreto:** En el ejercicio `broken_gnl`, como en `get_next_line` del círculo anterior, debes leer de un fd por bloques (`BUFFER_SIZE`), guardar lo leído en memoria y devolver exactamente una línea por cada llamada a la función, escribiendo solo lo necesario.

> En detalle: todos los ejercicios de nivel 1 giran en torno al manejo manual de la entrada y salida en C, principalmente leyendo de la entrada estándar (`stdin`) o desde descriptores de archivo (`fd`) usando funciones de bajo nivel como `read` o de más alto nivel como `fgetc`. El objetivo es procesar los datos (strings, bloques de texto, líneas) y escribir el resultado en la salida estándar (`stdout`), siempre gestionando la memoria de forma explícita (reservar, liberar, evitar fugas).  
> Esto implica controlar cómo y cuánto se lee, cómo se almacenan y modifican los datos en buffers, y asegurarse de que la salida cumple el formato requerido. No se usan funciones avanzadas ni estructuras complejas, el reto está en el dominio de las bases del lenguaje y la gestión eficiente de recursos.

---

## Nivel 2

### 1. tsp (Traveling Salesman Problem)
- **Objetivo:** Leer coordenadas de ciudades desde stdin y calcular la longitud mínima del camino cerrado que pasa por todas las ciudades una sola vez.
- **Salida:** La longitud mínima, con dos decimales.
- **Técnica:** Fuerza bruta con backtracking/permutaciones (no más de 11 ciudades).
- **Temas:** Recorridos de grafos, permutaciones, cálculo de distancias.
- **Funciones permitidas:** `write`, `sqrtf`, `getline`, `fseek`, `fscanf`, `ferror`, `feof`, `fabsf`, `memcpy`, `fprintf`, `fclose`, `malloc`, `calloc`, `realloc`, `free`, `fopen`, `errno`, `stderr`, `stdin`, `stdout`
- **Tipo:** Programa completo (con `main` propio, ejecutable).

### 2. rip
- **Objetivo:** Recibe una string de paréntesis. Si está desbalanceada, elimina (poniendo espacios) el mínimo número de paréntesis para que quede balanceada y muestra todas las soluciones posibles.
- **Salida:** Todas las variantes válidas posibles (una por línea).
- **Técnica:** Recursividad y backtracking probando quitar cada paréntesis.
- **Temas:** Strings, recursión, balance de paréntesis.
- **Funciones permitidas:** `puts`, `write`
- **Tipo:** Programa completo (con `main` propio, ejecutable).

### 3. permutations
- **Objetivo:** Imprime todas las permutaciones de los caracteres de la string recibida por argumento, en orden alfabético.
- **Salida:** Cada permutación en una línea.
- **Técnica:** Backtracking recursivo con swaps y revertiendo, con ordenación previa.
- **Temas:** Recursividad, generación de permutaciones, ordenación.
- **Funciones permitidas:** `puts`, `malloc`, `calloc`, `realloc`, `free`, `write`
- **Tipo:** Programa completo (con `main` propio, ejecutable).

### 4. n_queens
- **Objetivo:** Imprime todas las soluciones para colocar N reinas en un tablero NxN sin que se ataquen entre sí.
- **Salida:** Cada solución es una línea de índices (posición de la reina en cada columna).
- **Técnica:** Backtracking profundo probando todas las posiciones posibles.
- **Temas:** Recursividad, búsqueda en espacio de soluciones, combinatoria.
- **Funciones permitidas:** `atoi`, `fprintf`, `write`
- **Tipo:** Programa completo (con `main` propio, ejecutable).

### 5. powerset
- **Objetivo:** Recibe un número n y una lista de enteros. Imprime todos los subconjuntos cuya suma es n.
- **Salida:** Cada subconjunto válido en una línea, en orden de entrada.
- **Técnica:** Backtracking recursivo para probar todas las combinaciones posibles.
- **Temas:** Subconjuntos, suma de subconjuntos, recursividad.
- **Funciones permitidas:** `atoi`, `printf`, `malloc`, `calloc`, `realloc`, `free`
- **Tipo:** Programa completo (con `main` propio, ejecutable).

---
### ¿Qué tienen en común los ejercicios de Nivel 2?
- El foco está en **recursividad** y **backtracking** para explorar soluciones combinatorias y resolver problemas clásicos de algoritmos.

---

### ¿Qué significa recursividad y backtracking en estos ejercicios?

**Recursividad**
- Los programas resuelven problemas complejos dividiéndolos en subproblemas más pequeños que se llaman a sí mismos (funciones recursivas).
- Por ejemplo, para permutar o repartir elementos, la función se llama repetidamente con diferentes opciones hasta cubrir todas las posibilidades.

**Backtracking**
- Es una técnica para explorar todas las soluciones posibles: se prueba una opción, y si no es válida, se retrocede ("backtrack") y se prueba otra.
- Se usa para encontrar todas las combinaciones, permutaciones, soluciones de n reinas, subconjuntos, etc.
- Permite generar variantes válidas, optimizar recorridos, o filtrar resultados conforme a restricciones (por ejemplo, balance de paréntesis o suma específica).

**¿Por qué es importante?**
- **Exploración completa:** Permite analizar todo el espacio de soluciones, garantizando que no se escapa ningún caso.
- **Solución óptima o exhaustiva:** Es ideal para problemas donde hay que encontrar la mejor solución, todas las posibles, o simplemente recorrer todas las combinaciones.
- **Ejemplo concreto:** En `tsp`, se prueban todas las rutas posibles; en `n_queens`, todas las posiciones; en `powerset`, todos los subconjuntos que suman el número dado.

> En detalle: todos los ejercicios de nivel 2 están basados en algoritmos de **recursividad** y **backtracking**, donde la clave es generar y explorar múltiples configuraciones o soluciones, ya sea buscando la óptima, todas las válidas, o las que cumplen ciertas condiciones. El reto está en estructurar bien las llamadas recursivas, controlar la vuelta atrás (backtracking) y manejar correctamente los datos en cada paso, siempre con funciones permitidas y evitando estructuras avanzadas.

---

Cada carpeta de cada ejercicio contiene:
- `subject.txt` (enunciado original).
- `*.c` (esqueleto base para empezar) o bien archivos dados que usar o modificar.

¡A practicar!
